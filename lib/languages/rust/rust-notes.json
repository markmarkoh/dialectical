{
  "modules": "Rust organizes code into modules with explicit visibility control using the 'pub' keyword. Modules can be defined in separate files or nested within other modules, creating a hierarchical structure. The module system is designed to support encapsulation and code organization.",
  "imports": "Rust uses 'use' statements to bring items into scope. It supports nested paths, re-exports, and glob imports. The import system is designed to be explicit about what's being imported while minimizing namespace pollution.",
  "type-checking": "Rust has a strong, static type system with compile-time checking. Its type system is designed around ownership, borrowing, and lifetimes, which enable memory safety without garbage collection. Rust's type system prevents data races and null pointer dereferences at compile time.",
  "scalar-types": "Rust has a rich set of primitive types with explicit sizes: integers (i8 to i128, u8 to u128), floating-point numbers (f32, f64), booleans, characters, and string slices. Rust's type system ensures that operations on these types are safe and predictable.",
  "assignments": "Rust uses 'let' for immutable bindings by default and 'let mut' for mutable bindings. This emphasis on immutability by default helps prevent bugs. Rust's ownership system tracks who can read and write to memory, preventing data races.",
  "type-annotations": "Rust requires type annotations for function parameters and return types, but uses type inference for local variables. This balance ensures code clarity at API boundaries while reducing verbosity within function bodies.",
  "lexical-blocks": "Rust uses curly braces for blocks, which are expressions that return values. The last expression in a block (without a semicolon) becomes the block's value. This expression-oriented approach reduces the need for explicit return statements.",
  "constants": "Rust uses 'const' for compile-time constants and 'static' for static variables with a fixed memory address. Constants are inlined at compile time and can only be set to constant expressions, not the result of function calls with dynamic values.",
  "function-definitions": "Rust functions are defined with the 'fn' keyword and require explicit type annotations for parameters and return values. Functions can be generic, accept closures, and have associated functions (similar to static methods) when defined within an impl block.",
  "anonymous-functions": "Rust uses closures with a concise syntax: |params| body. Closures can capture their environment by reference or by value (using the 'move' keyword). Rust's ownership system ensures that closures don't outlive the variables they capture.",
  "function-arguments": "Rust passes arguments by value by default, but references (&T) and mutable references (&mut T) can be used for efficiency and to allow functions to modify their arguments. Rust's ownership system ensures that references are always valid.",
  "generics": "Rust has a powerful generics system with trait bounds for constraining generic types. This allows for code reuse without runtime overhead, as generic functions are monomorphized at compile time. Traits provide a flexible way to define shared behavior.",
  "pattern-matching": "Rust has powerful pattern matching with the 'match' expression, which must be exhaustive. Patterns can destructure structs, enums, tuples, and arrays, and can include guards for additional conditions. Pattern matching is a core feature of Rust's design.",
  "if-else": "Rust's if/else constructs are expressions that return values, allowing for concise conditional assignment. Rust doesn't have an explicit 'else if' syntax, but consecutive 'else if' blocks work as expected.",
  "recursion": "Rust supports recursion but doesn't automatically optimize tail calls, so deep recursion can cause stack overflows. Iterative approaches are often preferred for performance-critical code.",
  "guards": "Rust uses pattern guards with 'if' conditions in match arms to add additional constraints to patterns. This allows for more expressive pattern matching and can simplify complex conditional logic.",
  "error-handling": "Rust uses the Result<T, E> type for recoverable errors and panic! for unrecoverable errors. The ? operator provides syntactic sugar for propagating errors. This approach makes error handling explicit and encourages proper error management.",
  "loops": "Rust provides several loop constructs: 'for' for iteration over collections, 'while' for conditional loops, and 'loop' for infinite loops. Loops can be labeled for breaking out of nested loops, and can return values when broken with an expression.",
  "macros": "Rust has a powerful macro system with declarative macros (macro_rules!) and procedural macros. Macros allow for metaprogramming, code generation, and domain-specific languages. They're used extensively in the standard library and ecosystem.",
  "basic-networking": "Rust's standard library provides basic networking primitives, but most developers use crates like 'tokio' or 'async-std' for asynchronous networking. These libraries provide high-performance, safe abstractions over system-level networking APIs.",
  "memory-management": "Rust's memory management is based on ownership, borrowing, and lifetimes. Ownership ensures that each value has a single owner, and when the owner goes out of scope, the value is dropped. Borrowing allows safe access to data without transferring ownership. Lifetimes prevent dangling pointers. Smart pointers like Box<T> and Rc<T> provide additional memory management features."
}

