{
  "modules": "Zig uses files as modules. The @import builtin function is used to import other modules, and the 'pub' keyword makes declarations available to other modules. Zig's module system is simpler than many languages, with no namespaces or complex visibility rules.",
  "imports": "Zig uses the @import builtin function to import other modules. Unlike many languages, there's no special import statement or syntax. The result of @import is typically assigned to a constant with the same name as the module for convenience.",
  "type-checking": "Zig is statically typed with compile-time type checking. It has a strong focus on explicitness, with no implicit type conversions. Zig adds compile-time execution (comptime) for powerful type-level programming and metaprogramming.",
  "scalar-types": "Zig has explicit integer types (i8 to i128, u8 to u128), floating point types (f16, f32, f64, f128), and bool. It adds special types like error unions (anyerror!T) and optionals (?T) as core language features. Strings are represented as slices of bytes ([]u8).",
  "assignments": "Zig uses 'const' for immutable bindings and 'var' for mutable ones. Variables must be initialized, but can be explicitly marked as 'undefined'. Zig's approach to mutability is similar to Rust but with simpler rules.",
  "type-annotations": "Type annotations in Zig appear after the variable name, separated by a colon. Zig has a rich type system with explicit sizes for numeric types, pointers, arrays, slices, structs, unions, enums, and error unions. Type inference is available but limited.",
  "lexical-blocks": "Zig uses curly braces for blocks. Blocks can be labeled and used as expressions with the 'break :label value' syntax. This provides a way to return values from blocks similar to expression-oriented languages, but with explicit control flow.",
  "constants": "Zig uses 'const' for compile-time constants. It adds 'comptime' for more complex compile-time computations, allowing powerful metaprogramming. Zig's approach to constants is deeply integrated with its compile-time execution model.",
  "function-definitions": "Zig functions are defined with the 'fn' keyword. They require explicit return types and return statements. Zig supports error union returns for error handling and has special syntax for variadic functions and extern functions for C interoperability.",
  "anonymous-functions": "Zig doesn't have built-in anonymous functions or closures. Instead, it uses function pointers and structs with function fields to achieve similar functionality. This approach is more explicit about memory management and lifetime issues.",
  "function-arguments": "Zig passes arguments by value by default. Pointers can be used for pass-by-reference semantics. Zig doesn't have default parameters or variadic functions in the traditional sense, but supports C-style variadic functions and compile-time parameter lists.",
  "generics": "Zig uses comptime parameters for generics, rather than a separate generic syntax. This approach is more flexible and powerful than traditional generics, allowing arbitrary compile-time computation to generate specialized code.",
  "pattern-matching": "Zig doesn't have built-in pattern matching like some functional languages. Instead, it uses switch statements and destructuring to achieve similar results. Zig's switch is exhaustive and doesn't fall through by default.",
  "if-else": "Zig's if statements can capture values from optionals and error unions, similar to pattern matching in other languages. If statements require explicit boolean conditions and don't have implicit conversions. If can be used as an expression with explicit returns.",
  "recursion": "Zig supports recursion like most languages, but doesn't optimize tail calls automatically. Deep recursion can cause stack overflow, so iterative approaches are often preferred for performance-critical code.",
  "guards": "Zig doesn't have dedicated guard clauses, but achieves similar functionality through early returns and its error handling system. The language encourages explicit error checking and handling.",
  "error-handling": "Zig uses error unions (anyerror!T) and the try/catch/errdefer keywords for error handling. This approach makes errors part of the type system and ensures they're handled explicitly. Zig doesn't have exceptions in the traditional sense.",
  "loops": "Zig has for loops and while loops with explicit conditions. It adds special loop types like 'inline for' for compile-time iteration and 'comptime for' for generating code. Zig's loops are more explicit about memory management than many languages.",
  "macros": "Zig doesn't have traditional macros, but its compile-time execution (comptime) provides similar or greater capabilities. This approach is more integrated with the language and type system, avoiding many of the pitfalls of traditional macro systems.",
  "basic-networking": "Zig doesn't have built-in networking libraries in its standard library yet, as it's still evolving. Networking is typically done through C interoperability or community libraries. The language provides low-level memory management features that are useful for implementing efficient networking code.",
  "memory-management": "Zig's memory management is manual, with explicit allocation and deallocation using allocators. The standard library provides a page allocator and arena allocators. Zig emphasizes explicit control over memory, with no garbage collection. This gives developers fine-grained control over memory usage, but requires careful management to avoid memory leaks and other issues."
}

